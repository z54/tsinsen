/*
 【问题描述】
信息学院有四个专业A、B、C、D，各专业入学新生人数分别是Na, Nb, Nc，Nd人。新学期开始有一门公共课，按专业划分成四个教学班，
四个班在某个相同的时间段上课。已知该时间段还剩余8间教室可用，编号从1到8，每个教室能容纳的人数分别为120，40，85，50，100，140，70，100。
试编一个程序，为上述四个教学班分配教室。
找出所有可行的分配方案，对于每个方案依次输出为专业A、B、C、D分配的教室编号，按照字典顺序输出所有方案。
 
【输入格式】
一行，包含4个整数Na, Nb, Nc，Nd (20≤Na, Nb, Nc，Nd≤120)，每2个整数之间用一个空格隔开。
 
【输出格式】
如果存在分配方案，输出若干行，每行表示一种教室分配方案，包含4个整数，依次表示A、B、C、D四个专业分配的教室编号。
注意：按照字典序输出所有方案。
如果不存在分配方案，输出-1。
【样例输入1】
109 87 120 81
 
【样例输出1】
1 5 6 3
1 5 6 8
1 8 6 3
1 8 6 5
6 5 1 3
6 5 1 8
6 8 1 3
6 8 1 5
 
【样例输入2】
100 101 102 103
 
【样例输出2】
-1
*/

#include <stdio.h>
#include <string.h>

int sort(int li[], int length)
{
	
	int i, j, t;

	// for (j = length; j > 0; j--){	// 正序
	// 	for (i = 1; i < j; i++){
	// 		if (li[i] < li[i-1]){
	// 			t = li[i];
	// 			li[i] = li[i-1];
	// 			li[i-1] = t;
	// 		}
	// 	}
	// }
	for (j = 0; j < length; j++){	// 逆序
		for (i = length - 1; i > j; i--){
			if (li[i] > li[i-1]){
				t = li[i];
				li[i] = li[i-1];
				li[i-1] = t;
			}
		}
	}
	
	return 0;
}

int main(int argc, char const *argv[])
{
	/*
	建立两个数组分别存放班级人数及教室容纳量v
	复制人数数组后对新数组排序v
	判断不存在方案情况：人数第一超过140；人数第二超过120；人数第三超过100；v
	新数组与容纳数组对比，找出符合各班可以被容纳的教室
	根据各班可以被容纳的教室找出不重复组合
	*/
	int i, j, k = 0, f;
	int i2, i3, i4;
	int a[8] = {120, 40, 85, 50, 100, 140, 70, 100}; 
	// int a2[8];
	//40      50      70      85      100     100     120     140
	int n[4], n2[4], s[4][8] = {0};
	// int s[64][4];
	scanf ("%d %d %d %d", &n[0], &n[1], &n[2], &n[3]);
	// memcpy(a2,a,sizeof(a));
	memcpy(n2,n,sizeof(n));
	
	sort(n2, 4);

	if (n2[0] > 140 || n2[1] > 120 || n2[2] > 100 || n[3] < 0){
		printf("%d\n", -1);
	}

	//109 87 120 81
	for (f = 0,j = 0; f < 4; f++){//控制比较方
		for (i = 0; i < 8; i++){//控制被比较方
			if (n[f] <= a[i]){
				s[j][k] = i + 1;
				//printf("n[%d]=%d, a[%d]=%d,s[%d][%d]=%d\n", f, n[f], i, a[i], j, k, s[j][k]);
				k++;//控制列数
			}
		}
		k = 0;
		j++;//控制行数
	}

	/*for (i = 0; i < 4; i++){
		for (j = 0; j < 8; j++){
			if (s[i][j] != 0){
				s1[i][j] = s[i][j];
				for (i2 = 1; i2 < 4; i2++){
					for (j2 = 1; j2 < 8; j2++){
						if (s[i][j] != 0){
							s1[i][j] = s[i][j];
						}
					}
				}
			}
		}
	}*/
	for (i = 0; i < 8; i++){
		if (s[0][i] != 0){
			//printf("%d\t", s[0][i]);
			for (i2 = 0; i2 < 8; i2++){
				if (s[1][i2] != 0 && s[1][i2] != s[0][i]){
					//printf("%d\t", s[1][i2]);
					for (i3 = 0; i3 < 8; i3++){
						if (s[2][i3] != 0 && s[2][i3] != s[0][i] && s[2][i3] != s[1][i2]){
							//printf("%d\t", s[2][i3]);
							for (i4 = 0; i4 < 8; i4++){
								if (s[3][i4] != 0 && s[3][i4] != s[0][i] && s[3][i4] != s[1][i2] && s[3][i4] != s[2][i3]){
									printf ("%d %d %d %d\n", s[0][i], s[1][i2], s[2][i3], s[3][i4]);
								}
							}
						}
					}
				}
			}
		}
	}

	/*printf ("\n");
	for (i = 0; i < 8; i++){
		printf ("%d\t", a[i]);
	}
	printf("\n");
	for (i = 0; i < 4; i++){
		printf ("%d\t", n[i]);
	}
	printf("\n");
	for (i = 0; i < 4; i++){
		printf ("%d\t", n2[i]);
	}
	printf ("\n");
	for (i = 0; i < 4; i++){
		for (j = 0; j < 8; j++){
			printf ("%d\t", s[i][j]);
		}
		printf("\n");
	}
	printf ("\n");*/

	return 0;
}